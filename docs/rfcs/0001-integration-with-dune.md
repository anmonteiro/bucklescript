- Start Date: 2021-05-31
- RFC PR: https://github.com/melange-re/melange/pull/200

# Summary

To allow Melange users to leverage Dune `library` and `executable` stanzas as
it is currently possible with any other OCaml project.

# Basic example

Dune would allow to use Melange as another cross-compiler, e.g.

```dune
(context (default (targets (melange))))
```

Then, users would be able to define `library` and `executable` stanzas that
would be built by calling Melange binary `ocamlc`. To define the output format
and extension, a new stanza `melange` would be supported in `dune` files:
```dune
(executable
    (name foo)
    (modes melange)
    (melange (module es6) (suffix bs.js))
)
```

# Motivation

The main motivations are:

- Improve integration with existing projects with OCaml and Melange sources: by
adding first-class support for Melange in Dune, it becomes easier to configure
projects that share libraries between OCaml native and Melange targets.
- Improve build performance of Melange projects: the current way Melange defines
all rules explicitly adds some overhead to build process, which could be removed
if Melange was exposed as any other OCaml compiler. 

# Detailed design

Unlike Js_of_ocaml, `.cmo` artifacts generated by Melange can't be shared with
the default `native` environment, as Melange does not transform bytecode, but
starts to translate to JavaScript from [the lambda representation](https://dev.realworldocaml.org/compiler-backend.html).
So the least intrusive way to model Melange and Dune integration is to leverage
Dune's existing support for cross-compilation.

Changes required in Melange:

- expose `bsc` as `ocamlc`
- generate `cmo` files instead of `cmj` files
- modify command line flags so that they behave in a similar way to the default
`ocamlc` binary
- add support to produce JavaScript files in two steps: first generate `.cmo`
files from source files, then generate `.js` files from `.cmo` files (see
"`js.` targets" section below)

Changes required in Dune:

- add a new mode `melange` to `executable` stanza, e.g.
```dune
(executable (name foo) (modes melange))
```
- when building under `melange` mode, generate `cma` targets as directories with
artifacts inside (same way as it's done with `cmxa`)
- when building under `melange` mode, add `-bs-stop-after-cmj` to
`cmo`-generation rules
- when building under `melange` mode, add rules to generate `js` files from
`cmo` files (see "`js.` targets" section below)
- add an option, maybe as part of new stanza `melange`, to define which
JavaScript module format will be used (`es6` or `commonjs`), e.g.:
```dune
(executable
    (name foo)
    (modes melange)
    (melange (module es6))
)
```
- add an option to choose which suffix will be added to JavaScript files
(`.bs.js` is the default), e.g.:
```dune
(executable
    (name foo)
    (modes melange)
    (melange (suffix bs.js))
)
```
- add implicit handling targets with extension `.bs.js`, which will generate the
necessary build rules behind the scenes, same as it is done currently for
`bc.js` files in Js_of_ocaml.

### `.js` targets

One of the main challenges of Melange integration is that originally `bsc`
command would generate both `cmo` and `js` targets with same command, but they
need to be placed in separate directories. This does not play well with Dune
invariants, that require all targets of a single rule
[to be placed in same directory](https://github.com/ocaml/dune/blob/0490fd413b81cca473ef5e4fb0a6c876e000e953/src/dune_engine/rule.ml#L96-L110).

After [some recent changes](https://github.com/melange-re/melange/pull/199),
[@EduardoRFS](https://github.com/EduardoRFS) unlocked the possibility to
generate `js` files from `cmo` files, which allows to define `cmo` and `js`
artifacts with separate Dune rules. This allows to generate just `cmo` files
first:

```bash
ocamlc -o output.cmo -bs-stop-after-cmo -impl output.ml
```

And then generate `js` files:

```bash
ocamlc -o output.js output.cmo
```

One remaining question is how to resolve the `import` / `require` statements in
resulting JavaScript files, as they require knowledge about the relative paths
to each one of the dependent modules that a module depends on.

Right now, Melange [checks if the `js` file exist in the relative path](https://github.com/jchavarri/melange/blob/6524091f126ec720f7fb59873d18bdff9b001be2/jscomp/core/js_name_of_module_id.ml#L175) to get absolute paths to dependent modules, so in
order to solve the issue we could include both `cmo` and `js` paths when calling
`ocamlc`:
```bash
ocamlc -I where_your_cm_stuff_is -I where_your_js_is exe.cmo
```

But there might better approaches, like passing all load paths to dependencies
from the command line argument.

# Drawbacks

From users perspective, integration with Dune means that in-source compilation
would no longer be supported. This has upsides like more easily shareable
artifacts or caching, and removes the chances of accidentally committing build
artifacts under source control. But it can also make harder to configure certain
projects that require `js` assets to be co-locating with other assets like `css`
or images. This can be solved by using Dune copy rules.

Another downside is that this integration will add maintenance burden to Dune,
as it adds more modes, and expands the amount of use cases that need to be
supported. This is partially mitigated by leveraging cross-compilation.

It similarly adds more maintenance costs to Melange, which would need to support
both `bsconfig.json` workflow, as well as `dune` workflow.

Finally, internal changes in Melange implementation to support Dune might make
harder to incorporate upstream ReScript changes to Melange.

# Alternatives

The alternatives would be to either:
- remain compatible with `bsconfig.json`, with the limitations with OCaml
codebases described in "Motivation" section.
- or to do a deeper integration with Dune, by adding a 3rd library mode
`melange` (besides `byte` and `native`) that calls `bsc` directly. Essentially,
considering Melange as another "OCaml compilation mode". This approach would
allow for maximum flexibility on the Melange side, but would be very intrusive
towards Dune codebase, run into very large maintenance costs, and also require
to solve problems like ppxs compilation, which cross-compilation solves well
already.

# Adoption strategy

Melange users could migrate progressively to Dune, so both `bsc` and `ocamlc`
would need to be supported, at least temporarily.

Once the Dune integration has happened, it is expected that the users of
Melange would start upgrading some of the existing libraries so they are defined
in Dune terms. Note that one library could easily support both ecosystems by
just including both `bsconfig.json` and `dune` files in its source.
